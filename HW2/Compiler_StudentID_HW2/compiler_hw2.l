/* Definition section */
%{
#include "y.tab.h"	/* header file generated by bison */
#define BUF_SIZE 512
extern YYSTYPE yylval; //YYSTYPE
char buf[BUF_SIZE];
extern void dump_symbol();
extern void yyerror(char *s);
extern void se_error(char *s);
extern int print_sym_flag;
extern char table_buf[4096];
extern char message_buf[128];

/* This macro is used to record code line */
#define CONCAT { strncat(buf, yytext, BUF_SIZE - strlen(buf) - 1); }
%}

/* Define regular expression label */
digit		[0-9]
letter		[a-zA-Z]
integer     {digit}+
float       {digit}+"."{digit}+
id			{letter}+({letter}|{digit})*

%option yylineno

%x COMMENT STRING_STATE

/* Rules section */
%%

 /* Arithmetic */

"+"     { CONCAT; return ADD;}
"-" 	{ CONCAT; return SUB;}
"*" 	{ CONCAT; return MUL;}
"/" 	{ CONCAT; return DIV;}
"%"     { CONCAT; return MOD;}
"++"    { CONCAT; return INC;}
"--"    { CONCAT; return DEC;}

 /* Relational */
">"		{ CONCAT; return MT;}
"<"		{ CONCAT; return LT;}
">="	{ CONCAT; return MTE;}
"<="	{ CONCAT; return LTE;}
"=="	{ CONCAT; return EQ;}
"!="	{ CONCAT; return NE;}

 /* Assignment */
"="		{ CONCAT; return ASGN;}
"+="	{ CONCAT; return ADDASGN;}
"-="	{ CONCAT; return SUBASGN;}
"*="	{ CONCAT; return MULASGN;}
"/="	{ CONCAT; return DIVASGN;}
"%="	{ CONCAT; return MODASGN;}

 /* Logical */
"&&"	{ CONCAT; return AND;}
"||"	{ CONCAT; return OR;}
"!"		{ CONCAT; return NOT;}

 /* Delimiters */
"("		{ CONCAT; return LB;}
")"		{ CONCAT; return RB;}
"{"		{ CONCAT; return LCB;}
"}"		{ CONCAT; return RCB;}
"["		{ CONCAT; return LSB;}
"]"		{ CONCAT; return RSB;}
","		{ CONCAT; return COMMA;}

 /* Print Keywords */	
"print"		{ CONCAT; return PRINT;}

 /* Condition and Loop Keywords */
"if"		{ CONCAT; return IF;}
"else"		{ CONCAT; return ELSE;}
"for"		{ CONCAT; return FOR;}
"while"		{ CONCAT; return WHILE;}

 /* Declaration Keywords */
"void"		{ CONCAT;yylval.type_val = strdup(yytext);return VOID;}
"int"		{ CONCAT;yylval.type_val = strdup(yytext);return INT;}
"float"  	{ CONCAT;yylval.type_val = strdup(yytext);return FLOAT;}
"string"  	{ CONCAT;yylval.type_val = strdup(yytext);return STRING;}
"bool"  	{ CONCAT;yylval.type_val = strdup(yytext);return BOOL;}

 /* boolean Keywords */
"true"      { CONCAT; return TRUE;}
"false"     { CONCAT; return FALSE;}

"return"    { CONCAT; return RET;}

 /* String Constant */
\"				        { CONCAT;BEGIN STRING_STATE; }
<STRING_STATE>\"		{ CONCAT;BEGIN INITIAL; }
<STRING_STATE>[^"]*		{ CONCAT; yylval.string_val = strdup(yytext); return STR_CONST;}

 /* Number Constant */
{integer}	{	CONCAT;yylval.i_val = atoi(yytext); return I_CONST;}
{float}	    {	CONCAT;yylval.f_val = atof(yytext); return F_CONST;}

 /* C type Comment */
"/*"				{CONCAT; BEGIN COMMENT; }
<COMMENT>[^*\n]+	{CONCAT;  }
<COMMENT>\n			{if(strlen(buf)==0){
						printf("%d:\n",yylineno);strcpy(buf,"");
				     }
					 else{
						printf("%d: %s\n",yylineno,buf);strcpy(buf,"");
					 }
					}
<COMMENT>"*"		{CONCAT;  }
<COMMENT>"*/"		{CONCAT;  BEGIN INITIAL; }

 /* C++ type Comment */
\/\/.*	{ CONCAT; }

 /* Variable ID */
 {id}       {CONCAT;yylval.id_val = strdup(yytext);return ID;}

 /* others */
" "			{CONCAT;}
[;]         {CONCAT;  return SEMICOLON;}
[\n]        {	if(print_sym_flag != 2){
					if(strlen(buf)==0){printf("%d:\n",yylineno);strcpy(buf,"");}
					else{printf("%d: %s\n",yylineno,buf);strcpy(buf,"");}
				}
				if(print_sym_flag == 1){
				  print_sym_flag = 0;
				  printf("%s",table_buf);
				  strcpy(table_buf,"");
				}
				else if(print_sym_flag ==2){
					print_sym_flag = 0;
					se_error(message_buf);
					strcpy(message_buf,"");
				}
			}
[ \t]		{ CONCAT;} /* Ignore */
[^ \t\n] 	{ } /* Ignore other charactor sets */
<<EOF>>     { return 0;}

%%

int yywrap()
{
    return 1;
}
